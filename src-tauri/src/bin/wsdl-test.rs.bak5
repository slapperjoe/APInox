/// WSDL Test Utility

use std::fs::File;
use std::io::Write;
use std::time::Instant;
use chrono::Utc;

use apinox_lib::parsers::wsdl::{WsdlParser, ImportResolver};
use apinox_lib::http::HttpClient;

struct TestConfig {
    wsdl_url: String,
    max_depth: usize,
    output_file: String,
    resolve_imports: bool,
}

impl TestConfig {
    fn from_args() -> Result<Self, String> {
        let args: Vec<String> = std::env::args().collect();
        
        if args.len() < 2 {
            return Err("Usage: wsdl-test <wsdl-url> [--max-depth N] [--output FILE] [--no-imports]".to_string());
        }
        
        let mut config = TestConfig {
            wsdl_url: args[1].clone(),
            max_depth: 10,
            output_file: "wsdl-test-output.txt".to_string(),
            resolve_imports: true,
        };
        
        let mut i = 2;
        while i < args.len() {
            match args[i].as_str() {
                "--max-depth" => {
                    if i + 1 < args.len() {
                        config.max_depth = args[i + 1].parse()
                            .map_err(|_| "Invalid max-depth value")?;
                        i += 2;
                    } else {
                        return Err("--max-depth requires a value".to_string());
                    }
                }
                "--output" => {
                    if i + 1 < args.len() {
                        config.output_file = args[i + 1].clone();
                        i += 2;
                    } else {
                        return Err("--output requires a file path".to_string());
                    }
                }
                "--no-imports" => {
                    config.resolve_imports = false;
                    i += 1;
                }
                _ => {
                    return Err(format!("Unknown option: {}", args[i]));
                }
            }
        }
        
        Ok(config)
    }
}

struct TestOutput {
    file: String,
}

impl TestOutput {
    fn new() -> Self {
        Self {
            file: String::new(),
        }
    }
    
    fn log(&mut self, msg: &str) {
        println!("{}", msg);
        self.file.push_str(msg);
        self.file.push('\n');
    }
    
    fn section(&mut self, title: &str) {
        let sep = "-".repeat(65);
        self.log(&sep);
        self.log(title);
        self.log(&sep);
    }
    
    fn header(&mut self) {
        let sep = "=".repeat(65);
        self.log(&sep);
        self.log("WSDL PARSER TEST UTILITY");
        self.log(&sep);
        self.log("");
    }
    
    fn write_to_file(&self, path: &str) -> std::io::Result<()> {
        let mut file = File::create(path)?;
        file.write_all(self.file.as_bytes())?;
        Ok(())
    }
}

#[tokio::main]
async fn main() {
    let mut output = TestOutput::new();
    
    let config = match TestConfig::from_args() {
        Ok(c) => c,
        Err(e) => {
            eprintln!("Error: {}", e);
            std::process::exit(1);
        }
    };
    
    output.header();
    output.log(&format!("Input WSDL: {}", config.wsdl_url));
    output.log(&format!("Max Import Depth: {}", config.max_depth));
    output.log(&format!("Resolve Imports: {}", config.resolve_imports));
    output.log(&format!("Output File: {}", config.output_file));
    output.log(&format!("Timestamp: {}", Utc::now().format("%Y-%m-%d %H:%M:%S UTC")));
    output.log("");
    
    let result = run_test(&config, &mut output).await;
    
    if let Err(e) = output.write_to_file(&config.output_file) {
        eprintln!("Failed to write output file: {}", e);
    } else {
        println!("\n✓ Output written to: {}", config.output_file);
    }
    
    match result {
        Ok(_) => std::process::exit(0),
        Err(_) => std::process::exit(1),
    }
}

async fn run_test(config: &TestConfig, output: &mut TestOutput) -> Result<(), anyhow::Error> {
    let overall_start = Instant::now();
    
    output.section("PHASE 1: Fetching Main WSDL");
    
    let http_client = HttpClient::new()?;
    let start = Instant::now();
    let response = http_client.get(&config.wsdl_url, std::collections::HashMap::new()).await;
    let fetch_time = start.elapsed();
    
    if !response.success {
        let err = response.error.unwrap_or_else(|| format!("HTTP {}", response.status));
        output.log(&format!("✗ Failed: {}", err));
        return Err(anyhow::anyhow!("Failed to fetch WSDL: {}", err));
    }
    
    let wsdl_xml = response.body;
    output.log(&format!("✓ Fetched ({} bytes, {}ms)", wsdl_xml.len(), fetch_time.as_millis()));
    output.log("");
    
    let mut import_resolver = ImportResolver::new()?;
    if config.resolve_imports {
        output.section("PHASE 2: Resolving Imports");
        
        let imports = ImportResolver::parse_imports(&wsdl_xml)?;
        output.log(&format!("Found {} imports", imports.len()));
        
        for (i, import) in imports.iter().enumerate() {
            output.log(&format!("  {}. {}", i + 1, import.location));
        }
        output.log("");
        
        if !imports.is_empty() {
            for import_decl in imports {
                let start = Instant::now();
                match import_resolver.fetch_document(&import_decl.location, Some(&config.wsdl_url)).await {
                    Ok(xml) => {
                        output.log(&format!("  ✓ {} ({} bytes, {}ms)", 
                            import_decl.location, xml.len(), start.elapsed().as_millis()));
                    }
                    Err(e) => {
                        output.log(&format!("  ✗ {} - {}", import_decl.location, e));
                    }
                }
            }
        }
        output.log("");
    }
    
    output.section("PHASE 3: Parsing WSDL");
    
    
    let services = parser.parse(&wsdl_xml)?;
    
    output.log(&format!("Services: {}", services.len()));
    for svc in &services {
        output.log(&format!("  └─ {} ({} operations)", svc.name, svc.operations.len()));
        for (i, op) in svc.operations.iter().enumerate() {
            output.log(&format!("     {}. {}", i + 1, op.name));
        }
    }
    output.log("");
    
    output.section("PHASE 4: Schema Analysis");
    
    let mut with_schema = 0;
    let mut total_nodes = 0;
    
    for svc in &services {
        for op in &svc.operations {
            if let Some(schema) = &op.full_schema {
                with_schema += 1;
                total_nodes += count_nodes(schema);
            }
        }
    }
    
    let total_ops = services.iter().map(|s| s.operations.len()).sum::<usize>();
    output.log(&format!("Ops with schemas: {}/{}", with_schema, total_ops));
    output.log(&format!("Total schema nodes: {}", total_nodes));
    output.log("");
    
    output.section("PHASE 5: Operation Details");
    
    for svc in &services {
        for op in &svc.operations {
            output.log(&format!("Operation: {}", op.name));
            output.log(&format!("  Namespace: {}", op.target_namespace.as_ref().unwrap_or(&"-".to_string())));
            output.log(&format!("  Endpoint: {}", op.original_endpoint.as_ref().unwrap_or(&"-".to_string())));
            output.log(&format!("  Action: {}", op.action.as_ref().unwrap_or(&"-".to_string())));
            
            if let Some(schema) = &op.full_schema {
                output.log("  Schema:");
                dump_tree(schema, "    ", output);
            }
            output.log("");
        }
    }
    
    let total_time = overall_start.elapsed();
    output.section(&format!("✓ SUCCESS ({}ms)", total_time.as_millis()));
    output.log(&format!("{} services, {} operations parsed", services.len(), total_ops));
    
    Ok(())
}

fn count_nodes(node: &apinox_lib::parsers::wsdl::SchemaNode) -> usize {
    let children_count = node.children.as_ref()
        .map(|children| children.iter().map(count_nodes).sum())
        .unwrap_or(0);
    1 + children_count
}

fn dump_tree(node: &apinox_lib::parsers::wsdl::SchemaNode, indent: &str, output: &mut TestOutput) {
    let req = if node.min_occurs.as_ref().map(|m| m == "0").unwrap_or(false) { "" } else { " *" };
    output.log(&format!("{}{} ({}){}", indent, node.name, node.node_type, req));
    
    if let Some(children) = &node.children {
        for child in children {
            dump_tree(child, &format!("{}  ", indent), output);
        }
    }
}
